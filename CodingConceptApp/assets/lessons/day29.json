[
  {
    "id": "day29-story-01",
    "kind": "story",
    "md": "# Day 29: 더 빠르고 효율적인 코드 만들기, 성능 최적화\n\n우리가 만든 프로그램이 빠르고 부드럽게 작동하는 것은 사용자 경험에 매우 중요합니다. 마치 잘 정비된 자동차가 더 효율적으로 달리는 것처럼, 프로그래밍에서도 코드의 '성능을 최적화'하여 더 빠르고 효율적인 애플리케이션을 만들 수 있습니다. 성능 최적화는 단순히 코드를 빠르게 만드는 것을 넘어, 자원 사용을 줄이고 사용자 만족도를 높이는 과정입니다."
  },
  {
    "id": "day29-concept-01",
    "kind": "concept",
    "md": "# 성능 최적화 (Performance Optimization)의 중요성\n\n**성능 최적화**는 소프트웨어의 실행 속도를 향상시키고, 메모리 사용량, 네트워크 요청 등 자원 소비를 줄이는 일련의 과정입니다. 특히 웹 애플리케이션에서는 빠른 로딩 속도와 부드러운 사용자 인터페이스가 중요합니다.\n\n- **사용자 경험 (UX) 향상:** 빠른 웹사이트는 사용자의 만족도를 높이고 이탈률을 줄입니다.\n- **검색 엔진 최적화 (SEO):** 검색 엔진은 빠른 웹사이트에 더 높은 순위를 부여합니다.\n- **전환율 증가:** 전자상거래 등에서 성능 개선은 매출 증대로 이어질 수 있습니다.\n- **자원 효율성:** 서버 부하를 줄이고 에너지 소비를 절감합니다."
  },
  {
    "id": "day29-example-01",
    "kind": "example",
    "md": "# JavaScript 코드 최적화 기법\n\nJavaScript 코드 자체를 최적화하는 몇 가지 방법입니다.\n\n```javascript\n// 1. 불필요한 이벤트 리스너 제거\n// DOM 요소가 사라질 때 이벤트 리스너도 함께 제거하여 메모리 누수 방지\nconst button = document.getElementById('myButton');\nconst handleClick = () => { /* ... */ };\nbutton.addEventListener('click', handleClick);\n\n// 요소가 더 이상 필요 없을 때\n// button.removeEventListener('click', handleClick);\n\n// 2. GC-friendly 코드 작성 (가비지 컬렉션에 친화적인 코드)\n// 더 이상 사용하지 않는 객체에 대한 참조를 null로 설정하여 가비지 컬렉션 대상이 되도록 유도\nlet largeObject = { data: Array(1000000).fill('some data') };\n// ... largeObject 사용 ...\nlargeObject = null; // 참조 제거\n\n// 3. 루프 최적화\n// 불필요한 계산을 루프 밖으로 빼내기\nconst arr = [1, 2, 3, 4, 5];\nconst arrLength = arr.length; // 루프마다 length를 계산하는 대신 미리 저장\nfor (let i = 0; i < arrLength; i++) {\n  // ...\n}\n\n// 4. DOM 조작 최소화\n// DOM 조작은 비용이 많이 드므로, 한 번에 여러 변경 사항을 적용\nconst list = document.getElementById('myList');\nlet fragment = document.createDocumentFragment();\nfor (let i = 0; i < 100; i++) {\n  const li = document.createElement('li');\n  li.textContent = `아이템 ${i}`;\n  fragment.appendChild(li);\n}\nlist.appendChild(fragment); // 한 번의 DOM 조작으로 추가\n```\n\n이러한 기법들은 코드의 실행 속도를 높이고 메모리 사용량을 줄이는 데 기여합니다."
  },
  {
    "id": "day29-concept-02",
    "kind": "concept",
    "md": "# 웹 성능 최적화의 다양한 측면\n\nJavaScript 코드 최적화 외에도 웹 성능을 개선하기 위한 다양한 방법들이 있습니다.\n\n- **이미지 최적화:** WebP, AVIF 같은 차세대 포맷 사용, 이미지 크기 축소 및 압축, Lazy loading 적용.\n- **CSS/JS 최적화:** 미사용 코드 제거(Tree shaking, PurgeCSS), 파일 압축 및 병합(Minify, Bundle), JavaScript는 `defer` 또는 `async`로 로드.\n- **코드 분할 (Code Splitting):** 초기 로딩 속도를 줄이기 위해 필요한 기능만 동적으로 로드.\n- **캐싱 전략:** HTTP 캐시 헤더 활용, 서비스 워커로 오프라인 캐싱 구현.\n- **렌더링 최적화:** Critical CSS 인라인화, 리플로우/리페인트를 유발하는 스타일 변경 최소화, 애니메이션은 `transform`과 `opacity` 사용.\n- **서버 및 네트워크:** Gzip/Brotli 압축, CDN(Content Delivery Network) 사용, HTTP/2 또는 HTTP/3 적용.\n- **성능 측정 도구:** Lighthouse (Chrome DevTools), WebPageTest, PageSpeed Insights 등으로 성능 분석."
  },
  {
    "id": "day29-example-02",
    "kind": "example",
    "md": "# 웹팩 (Webpack)을 이용한 번들링 및 최적화\n\nWebpack은 모던 JavaScript 개발 환경에서 번들링 및 다양한 최적화 작업을 수행하는 데 널리 사용됩니다.\n\n**`webpack.config.js` (간단한 예시):**\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'production', // 'development' 또는 'production'\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader', // Babel을 사용하여 ES6+ 코드를 변환\n          options: {\n            presets: ['@babel/preset-env'],\n          },\n        },\n      },\n    ],\n  },\n  optimization: {\n    minimize: true, // 코드 압축 (Minification)\n  },\n};\n```\n\nWebpack과 같은 번들러는 코드 분할, 압축, 트랜스파일링 등 복잡한 최적화 작업을 자동화하여 개발자가 성능에 집중할 수 있도록 돕습니다."
  },
  {
    "id": "day29-quiz-01",
    "kind": "quiz",
    "quizId": "quiz-day29-01"
  },
  {
    "id": "day29-lab-01",
    "kind": "lab",
    "labId": "lab-day29-01"
  },
  {
    "id": "day29-review-01",
    "kind": "review",
    "md": "# Day 29 복습\n\n오늘은 성능 최적화의 중요성, JavaScript 코드 최적화 기법, 그리고 웹 성능 최적화를 위한 다양한 측면(이미지, CSS/JS, 번들링 등)에 대해 학습했습니다. 성능 최적화는 사용자 경험을 개선하고 효율적인 웹 애플리케이션을 만드는 데 필수적인 과정입니다.\n\n다음 시간에는 '프레임워크와 라이브러리'에 대해 알아보겠습니다!"
  }
]
