[
  {
    "id": "day23-story-01",
    "kind": "story",
    "md": "# Day 23: 사용하지 않는 메모리를 자동으로 정리하는 방법, 가비지 컬렉션\n\n우리가 사용하지 않는 물건을 버리거나 정리하는 것처럼, 컴퓨터 프로그램도 더 이상 필요 없는 데이터를 메모리에서 자동으로 제거하여 효율적으로 관리해야 합니다. JavaScript에서는 이 작업을 '가비지 컬렉션'이라는 특별한 메커니즘이 담당합니다. 가비지 컬렉션은 개발자가 직접 메모리를 관리하는 복잡성을 줄여줍니다."
  },
  {
    "id": "day23-concept-01",
    "kind": "concept",
    "md": "# 가비지 컬렉션 (Garbage Collection)\n\n**가비지 컬렉션**은 프로그램이 더 이상 사용하지 않는 메모리(객체)를 자동으로 찾아내어 해제하는 과정입니다. JavaScript와 같은 고수준 언어에서는 개발자가 직접 메모리를 할당하고 해제할 필요 없이, 가비지 컬렉터가 이 작업을 대신 수행합니다.\n\n- **메모리 생존 주기:**\n  1. **할당:** 변수 선언, 함수 호출 등으로 메모리가 할당됩니다.\n  2. **사용:** 할당된 메모리의 값을 읽거나 씁니다.\n  3. **해제:** 더 이상 필요 없는 메모리를 해제합니다. (가비지 컬렉터가 담당)\n\n가비지 컬렉터는 어떤 메모리가 '더 이상 필요 없는지'를 판단하기 위해 다양한 알고리즘을 사용합니다."
  },
  {
    "id": "day23-example-01",
    "kind": "example",
    "md": "# 가비지 컬렉션의 기본 원리\n\n```javascript\nlet user = { name: \"Alice\" }; // 1. 객체 할당 (메모리 사용 시작)\n\nuser = null; // 2. user 변수가 더 이상 객체를 참조하지 않음\n             //    이 시점에서 { name: \"Alice\" } 객체는 '도달 불가능'해짐\n             //    가비지 컬렉터가 이 객체를 메모리에서 해제할 수 있음\n\nlet data = [1, 2, 3]; // 1. 배열 할당\nlet copy = data;      // 2. copy도 같은 배열을 참조\n\ndata = null;          // 3. data는 참조를 잃었지만, copy가 여전히 참조 중\n                      //    따라서 배열은 아직 가비지 컬렉션 대상이 아님\n\ncopy = null;          // 4. copy도 참조를 잃음. 배열은 이제 도달 불가능\n                      //    가비지 컬렉터가 배열을 해제할 수 있음\n```\n\n가비지 컬렉터는 객체가 '도달 불가능(unreachable)'해졌을 때 메모리를 해제합니다. 즉, 프로그램의 어떤 부분에서도 해당 객체에 접근할 수 없을 때를 의미합니다."
  },
  {
    "id": "day23-concept-02",
    "kind": "concept",
    "md": "# 가비지 컬렉션 알고리즘: Mark-and-sweep\n\n현대의 JavaScript 엔진은 주로 **Mark-and-sweep(표시하고-쓸기)** 알고리즘을 사용하여 가비지 컬렉션을 수행합니다.\n\n- **Root:** 전역 객체(예: 브라우저의 `window` 객체, Node.js의 `global` 객체)와 같이 항상 도달할 수 있는 객체들을 '루트(roots)'라고 합니다.\n- **Mark (표시):** 가비지 컬렉터는 루트에서 시작하여 루트가 참조하는 모든 객체, 그리고 그 객체들이 참조하는 객체들을 재귀적으로 '표시'합니다. 이렇게 표시된 객체들은 '도달 가능한' 객체로 간주됩니다.\n- **Sweep (쓸기):** 표시되지 않은 모든 객체(즉, 루트에서부터 도달할 수 없는 객체)는 '가비지'로 간주되어 메모리에서 '쓸어버려(해제)'집니다.\n\n이 알고리즘은 순환 참조(두 개 이상의 객체가 서로를 참조하는 경우) 문제도 해결할 수 있습니다. 순환 참조가 있더라도 루트에서 도달할 수 없다면 가비지 컬렉션 대상이 됩니다."
  },
  {
    "id": "day23-example-02",
    "kind": "example",
    "md": "# 순환 참조와 Mark-and-sweep\n\n```javascript\nfunction createCircularReference() {\n  let obj1 = {};\n  let obj2 = {};\n\n  obj1.a = obj2; // obj1이 obj2를 참조\n  obj2.a = obj1; // obj2가 obj1을 참조 (순환 참조)\n\n  return \"순환 참조 생성됨\";\n}\n\nlet result = createCircularReference();\nconsole.log(result); // 결과: 순환 참조 생성됨\n\n// createCircularReference 함수가 종료되면,\n// obj1과 obj2는 더 이상 외부에서 접근할 수 없게 됩니다.\n// Mark-and-sweep 알고리즘은 루트에서부터 이 객체들에 도달할 수 없으므로,\n// 순환 참조가 있더라도 이들을 가비지 컬렉션 대상으로 판단하여 메모리를 해제합니다.\n```\n\nMark-and-sweep 알고리즘 덕분에 JavaScript 개발자는 대부분의 메모리 누수 문제로부터 자유로울 수 있습니다."
  },
  {
    "id": "day23-quiz-01",
    "kind": "quiz",
    "quizId": "quiz-day23-01"
  },
  {
    "id": "day23-lab-01",
    "kind": "lab",
    "labId": "lab-day23-01"
  },
  {
    "id": "day23-review-01",
    "kind": "review",
    "md": "# Day 23 복습\n\n오늘은 가비지 컬렉션의 개념과 JavaScript의 주요 가비지 컬렉션 알고리즘인 Mark-and-sweep에 대해 학습했습니다. 가비지 컬렉션은 개발자가 메모리 관리에 대한 부담을 덜고, 프로그램이 안정적으로 동작하도록 돕는 중요한 메커니즘입니다.\n\n다음 시간에는 '프로토타입'에 대해 알아보겠습니다!"
  }
]
